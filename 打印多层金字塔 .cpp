
#include<stdio.h>

int main() {/*思路是：从最上面开始垒金字塔*/
	int M, m, i, j, k, l, s, x, y, a, b = 1;/*最终的大金字塔是若干个小金字塔叠加的，每一行小金字塔视为一大层，即为M；小金字塔的层数则为m*/
	scanf("%d%d", &M, &m);/*k是递减的空格数，因为大金字塔左边就是一斜到底*//*j是镂空的空格，递增，找一个样例可以观察得到*/
	for (l = M; l > 0; l--, b++) { /*这个控制大金字塔的层数，有几层，运行几次*/
		for (i = 0, s = m - 1; i < m; i++, s--) {/*这个控制小金字塔的层数，有几层，运行几次*/
			y = 0;/*y每次要重置为零*/
			for (k = l * m - i - 1; k > 0; k--)/*控制金字塔左边的空格*/
				printf(" ");
			if (b > 1) {/*b是1的时候，大金字塔就是小金字塔，但当大层数大于1时，下面的小金字塔中间有空格，所以这里分两种情况*/
				for (j = 0; j < (2 * i + 1) * b; j++) {/*用来控制下层小金字塔中的空格*/
					printf("*");/*从左边垒小金字塔*/
					y++;
					if (y == 2 * i + 1 && j != (2 * i + 1) * b - 1) {/*通过黑框框测试，一步步把这一大层的小金字塔垒完*/
						y = 0;/*y每次要重置为零*/
						for (x = s * 2 + 1; x > 0; x--)/*垒完小金字塔垒空格，再循环回去再垒小金字塔*/
							printf(" ");
					}
				}
			}/*垒完这一大层小金字塔再垒下一层的小金字塔*/
			else {
				for (j = 0; j < 2 * i + 1; j++)/*这里就是讲的只有大金塔内部没有空格的情况*/
					printf("*");
			}

			printf("\n");
		}
	}

	return 0;

}
